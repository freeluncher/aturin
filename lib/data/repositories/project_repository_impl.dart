import 'dart:async';

import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart' as supabase;
import 'package:connectivity_plus/connectivity_plus.dart';

import '../../domain/models/project.dart' as domain;
import '../../domain/repositories/project_repository.dart';
import '../local/app_database.dart';
import '../mappers/project_mapper.dart';

class ProjectRepositoryImpl implements ProjectRepository {
  final AppDatabase _db;
  final supabase.SupabaseClient _supabase;

  ProjectRepositoryImpl(this._db, this._supabase);

  @override
  Stream<List<domain.Project>> getProjects() {
    // 1. Return local data stream immediately
    final localStream = _db.select(_db.projects).watch().map((rows) {
      return rows.map((row) => row.toDomain()).toList();
    });

    // 2. Trigger background sync
    _syncFromRemote();

    return localStream;
  }

  @override
  Future<void> createProject(domain.Project project) async {
    // 1. Save to local DB
    await _db.into(_db.projects).insert(project.toCompanion());

    // 2. Sync to remote if online
    if (await _isOnline()) {
      try {
        await _supabase.from('projects').insert({
          'id': project
              .id, // Assuming same ID strategy for simplicity, or map server_id later
          'name': project.name,
          'description': project.description,
          'created_at': project.createdAt.toIso8601String(),
          'last_updated': project.lastUpdated.toIso8601String(),
          // 'server_id' might be generated by Supabase if we omit it, or we use UUID as PK everywhere
        });

        // Update local to set isSynced = true
        await (_db.update(_db.projects)..where((t) => t.id.equals(project.id)))
            .write(ProjectsCompanion(isSynced: const Value(true)));
      } catch (e) {
        // Ignore error, will sync later
        debugPrint('Error syncing createProject: $e');
      }
    }
  }

  @override
  Future<void> syncProjects() async {
    await _syncFromRemote();
  }

  Future<void> _syncFromRemote() async {
    if (!await _isOnline()) return;

    try {
      final response = await _supabase.from('projects').select();
      final remoteProjects = response as List<dynamic>;

      for (var data in remoteProjects) {
        final id = data['id'] as String;
        final name = data['name'] as String;
        final description = data['description'] as String;
        final lastUpdatedStr = data['last_updated'] as String?;
        final remoteLastUpdated = lastUpdatedStr != null
            ? DateTime.parse(lastUpdatedStr)
            : DateTime.now();

        // Check local modification
        final localProject = await (_db.select(
          _db.projects,
        )..where((t) => t.id.equals(id))).getSingleOrNull();

        if (localProject == null ||
            localProject.lastUpdated.isBefore(remoteLastUpdated)) {
          // Upsert into Drift
          await _db
              .into(_db.projects)
              .insertOnConflictUpdate(
                ProjectsCompanion.insert(
                  id: Value(id),
                  serverId: Value(
                    id,
                  ), // Assuming server_id matches id for simplicity
                  name: name,
                  description: description,
                  isSynced: const Value(true),
                  lastUpdated: Value(remoteLastUpdated),
                  // Handle other fields...
                ),
              );
        }
      }
      debugPrint('Sync completed for ${remoteProjects.length} items');
    } catch (e) {
      debugPrint('Sync failed: $e');
    }
  }

  Future<bool> _isOnline() async {
    final connectivityResult = await Connectivity().checkConnectivity();
    return !connectivityResult.contains(ConnectivityResult.none);
  }
}
